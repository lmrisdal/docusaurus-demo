"use strict";(self.webpackChunkdocusaurus_demo=self.webpackChunkdocusaurus_demo||[]).push([[6307],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return g}});var r=n(7294);function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){s(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,r,s=function(e,t){if(null==e)return{};var n,r,s={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(s[n]=e[n]);return s}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}var l=r.createContext({}),c=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},d=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},p=r.forwardRef((function(e,t){var n=e.components,s=e.mdxType,i=e.originalType,l=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),p=c(n),g=s,h=p["".concat(l,".").concat(g)]||p[g]||u[g]||i;return n?r.createElement(h,a(a({ref:t},d),{},{components:n})):r.createElement(h,a({ref:t},d))}));function g(e,t){var n=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var i=n.length,a=new Array(i);a[0]=p;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:s,a[1]=o;for(var c=2;c<i;c++)a[c]=n[c];return r.createElement.apply(null,a)}return r.createElement.apply(null,n)}p.displayName="MDXCreateElement"},9476:function(e,t,n){n.r(t),n.d(t,{assets:function(){return d},contentTitle:function(){return l},default:function(){return g},frontMatter:function(){return o},metadata:function(){return c},toc:function(){return u}});var r=n(7462),s=n(3366),i=(n(7294),n(3905)),a=["components"],o={},l="Resending",c={unversionedId:"resending",id:"resending",title:"Resending",description:"Resending in ConnXio (CX) functions differently based upon the event type you react to. Only one of the two event types are enabled at present which means that CX supports only one type of resending mechanism. We will describe both of them here, the non-active methods will be marked. If you need to use non-active methods, please contact us for more information.",source:"@site/docs/resending.md",sourceDirName:".",slug:"/resending",permalink:"/resending",draft:!1,editUrl:"https://github.com/lmrisdal/docusaurus-demo/tree/main/docs/resending.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Metadata",permalink:"/metadata"},next:{title:"Retry",permalink:"/retry"}},d={},u=[{value:"Stateless resending",id:"stateless-resending",level:2},{value:"Stateful resending",id:"stateful-resending",level:2},{value:"Resend Events",id:"resend-events",level:3}],p={toc:u};function g(e){var t=e.components,n=(0,s.Z)(e,a);return(0,i.kt)("wrapper",(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"resending"},"Resending"),(0,i.kt)("p",null,"Resending in ConnXio (CX) functions differently based upon the event type you react to. Only one of the two event types are enabled at present which means that CX supports only one type of resending mechanism. We will describe both of them here, the non-active methods will be marked. If you need to use non-active methods, please contact us for more information."),(0,i.kt)("h2",{id:"stateless-resending"},"Stateless resending"),(0,i.kt)("p",null,"By stateless resending we mean the process of resending a message from the beginning of the pipeline. This is really just a way to access any CX pipeline via an Api entry point. The endpoint used for stateless resending is hosted in the CX Api in the same way as the ",(0,i.kt)("a",{parentName:"p",href:"/Adapters/Inbound/Api"},"Api adapter")," in the ",(0,i.kt)("inlineCode",{parentName:"p"},"resend/archeo/restart")," Uri. We currently support the Archeo contract for resending only. This does not disqualify other systems from using the resending, they just have to conform to the Archeo contract which looks like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"    public class ArcheoResendEventRequest\n    {\n        public string TransactionId { get; set; }\n        public string ContentSasUri { get; set; }\n        public string ResendDateTime { get; set; }\n        public ArcheoLogStepMetaData LogStepMetaData { get; set; }\n    }\n\n    public class ArcheoLogStepMetaData\n    {\n        public string TransactionId { get; set; }\n        public string Description { get; set; }\n        public string TransactionTypeName { get; set; }\n        public string MessageTypeName { get; set; }\n        public string SenderName { get; set; }\n        public string RecieverName { get; set; }\n        public string StatusName { get; set; }\n        public string FileName { get; set; }\n        public DateTime Processed { get; set; }\n        public Dictionary<string, string> Metadata { get; set; }\n    }\n")),(0,i.kt)("p",null,"If you use the Archeo resending functionality all these fields are set and handled for you. If you want to use another system to pass resending requests to CX you need to fill out at least three fields:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"ArcheoResendEventRequest.TransactionId")," which represents the InterchangeId of the message. This should be set to the same id as the original message."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},'ArcheoResendEventRequest.LogStepMetaData.Metadata["ConfigCorrelatioId"]')," which describes the integration configuration to use when inflating the pipeline."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"ArcheoResendEventRequest.ContentSasUri")," which points to the message content SAS uri or hosted endpoint.")),(0,i.kt)("p",null,"As log as these three properties are set the resending event should restart the pipeline and keep logging to the same InterchangeId."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"If you use Archeo as the resending provider you do not need to set these properties manually as they are handled by Archeo when you set up a resending webhook.")),(0,i.kt)("p",null,"This concludes the description and tutorial for stateless resending. To summarize all you need to do to resend with this method is to create a Api request that contains a message Uri (presumably provided by the log event framework from CX and saved by your logging provider), an InterchangeId and a CorrelationId."),(0,i.kt)("h2",{id:"stateful-resending"},"Stateful resending"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"This functionality is in development. Read more on the:")," ",(0,i.kt)("a",{parentName:"p",href:"/Functionality"},"functionality page"),"."),(0,i.kt)("p",null,"Stateful resending refers to the process of re-inserting a message into the CX pipeline at the point of failure. This process is facilitated by a component within CX that performs draining of stopped messages within CX. Currently this process is developed but is non-active, which means that the required ",(0,i.kt)("a",{parentName:"p",href:"/Logging"},"Resendable")," events are not generated by the CX platform."),(0,i.kt)("p",null,"To resend a message with stateful resending you need to provide CX with a more detailed version of the ",(0,i.kt)("inlineCode",{parentName:"p"},"ArcheoResendEventRequest")," that contains encoded data which refers to the messages passed between engines within CX itself. Since this data is impossible to recreate outside CX you need the provided Resendable events to be able to use stateful resending."),(0,i.kt)("p",null,"When a Resendable event is received in your provider of choice you can map the event to the inbound model defined on the ",(0,i.kt)("inlineCode",{parentName:"p"},"resend/archeo")," endpoint and restart the pipeline. Including the fields required for the stateless resending process you also need to fill the following field:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},'ArcheoResendEventRequest.LogStepMetaData.Metadata["OriginalSbMessage"]')," which should contain the encoded version of the internal queuing information supplied by the resendable event.")),(0,i.kt)("h3",{id:"resend-events"},"Resend Events"),(0,i.kt)("p",null,'Resend events or "Resendable events" (defined by the Resendable status) are events generated within the stateful resend process. They are defined by one of two contracts. the first one is tailored to the Archeo ecosystem while the send is the contract used by CX internally to define the events. We do not recommend using the internal contract at present as this functionality is still in development. The contracts are as follows:'),(0,i.kt)("p",null,"Archeo"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"public class ArcheoLogStep\n{\n    public string TransactionId { get; set; }\n    public string TransactionType { get; set; }\n    public string MessageType { get; set; }\n    public string TransactionTag { get; set; }\n    public DateTime Processed { get; set; }\n    public string Sender { get; set; }\n    public string Receiver { get; set; }\n    public string Description { get; set; }\n    public string FileName { get; set; }\n    public string Status { get; set; }\n    public byte[] BodyContent { get; set; }\n    public IDictionary<string, string> Metadata { get; set; }\n}\n")),(0,i.kt)("p",null,"Internal"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"public class ResendEvent\n{\n    public string InterchangeId { get; set; }\n    public byte[] EventContent { get; set; }\n    public string EventContentUri { get; set; }\n    public string QueueDrainingConfigId { get; set; }\n    public string TopicName { get; set; }\n    public string DlqPath { get; set; }\n    public string Reason { get; set; }\n    public string Filename { get; set; }\n    public DateTime? EnqueueTime { get; set; }\n    public string OriginalSbMessage { get; set; }\n}\n")))}g.isMDXComponent=!0}}]);